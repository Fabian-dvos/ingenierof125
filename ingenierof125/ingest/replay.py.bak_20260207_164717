from __future__ import annotations

import asyncio
import logging
import struct
from dataclasses import dataclass
from typing import BinaryIO, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from ingenierof125.core.stats import RuntimeStats


@dataclass(slots=True)
class ReplayStats:
    sent: int = 0


class PacketReplayer:
    """
    Reproduce archivos .ingrec.

    Compat:
      - versiones viejas podían pasar stats=RuntimeStats
      - versiones viejas podían pasar out=<queue> en __init__
    """

    def __init__(
        self,
        path: str,
        speed: float = 1.0,
        no_sleep: bool = False,
        out: Optional["asyncio.Queue[bytes]"] = None,
        stats: "RuntimeStats | None" = None,
        **_ignored: object,
    ) -> None:
        self._path = str(path)
        self._speed = max(0.01, float(speed))
        self._no_sleep = bool(no_sleep)
        self._default_out = out
        self._runtime_stats = stats
        self._log = logging.getLogger("ingenierof125.replay")
        self._stop = asyncio.Event()
        self.stats = ReplayStats()

    def stop(self) -> None:
        self._stop.set()

    async def run(self, out_queue: Optional["asyncio.Queue[bytes]"] = None) -> None:
        out = out_queue or self._default_out
        if out is None:
            raise ValueError("PacketReplayer.run() necesita out_queue (o pasar out= en __init__).")

        self._log.info("Replaying %s (speed=%.2f no_sleep=%s)", self._path, self._speed, self._no_sleep)

        with open(self._path, "rb") as f:
            await self._loop(f, out)

        self._log.info("Replay finished: sent=%s", self.stats.sent)

    async def _loop(self, f: BinaryIO, out_queue: "asyncio.Queue[bytes]") -> None:
        last_ts: Optional[float] = None

        while not self._stop.is_set():
            hdr = f.read(8)
            if not hdr:
                return

            (ts_ms,) = struct.unpack("<Q", hdr)
            ln_bytes = f.read(4)
            if len(ln_bytes) < 4:
                return

            (ln,) = struct.unpack("<I", ln_bytes)
            payload = f.read(ln)
            if len(payload) < ln:
                return

            if last_ts is not None and not self._no_sleep:
                dt = (ts_ms - last_ts) / 1000.0
                if dt > 0:
                    await asyncio.sleep(dt / self._speed)

            last_ts = ts_ms
            await out_queue.put(payload)
            self.stats.sent += 1
            if self._runtime_stats is not None:
                self._runtime_stats.replay_sent += 1