from __future__ import annotations

import asyncio
import logging

from ingenierof125.core.stats import RuntimeStats
from ingenierof125.state.manager import StateManager
from ingenierof125.telemetry.protocol import PacketHeader


class PacketDispatcher:
    def __init__(
        self,
        expected_packet_format: int,
        expected_game_year: int,
        stats: RuntimeStats | None = None,
        state_manager: StateManager | None = None,
        *,
        strict_format: bool = False,
        strict_game_year: bool = False,
    ) -> None:
        self._log = logging.getLogger("ingenierof125.dispatcher")
        self._stop = asyncio.Event()

        self._expected_packet_format = int(expected_packet_format)
        self._expected_game_year = int(expected_game_year)

        self._strict_format = bool(strict_format)
        self._strict_game_year = bool(strict_game_year)

        self._warned_format = False
        self._warned_year = False

        self._stats = stats or RuntimeStats()
        self._state = state_manager

    def stop(self) -> None:
        self._stop.set()

    async def run(self, in_queue: "asyncio.Queue[bytes]") -> None:
        self._log.info("Dispatcher running")
        while not self._stop.is_set():
            try:
                data = await asyncio.wait_for(in_queue.get(), timeout=0.5)
            except asyncio.TimeoutError:
                continue

            self._stats.dispatched_in += 1

            hdr = PacketHeader.try_parse(data)
            if hdr is None:
                self._stats.dropped_bad_header += 1
                continue

            # Strict checks (solo si estÃ¡n habilitados)
            if hdr.packet_format != self._expected_packet_format:
                if self._strict_format:
                    self._stats.dropped_format_mismatch += 1
                    continue
                if not self._warned_format:
                    self._warned_format = True
                    self._log.warning(
                        "packet_format mismatch (got=%s expected=%s) but strict_format=False -> ACCEPTING",
                        hdr.packet_format,
                        self._expected_packet_format,
                    )

            if hdr.game_year != self._expected_game_year:
                if self._strict_game_year:
                    self._stats.dropped_game_year_mismatch += 1
                    continue
                if not self._warned_year:
                    self._warned_year = True
                    self._log.warning(
                        "game_year mismatch (got=%s expected=%s) but strict_game_year=False -> ACCEPTING",
                        hdr.game_year,
                        self._expected_game_year,
                    )

            self._stats.by_packet_id[hdr.packet_id] = self._stats.by_packet_id.get(hdr.packet_id, 0) + 1
            self._stats.last_session_uid = hdr.session_uid
            self._stats.last_frame = hdr.frame_identifier
            self._stats.last_packet_id = hdr.packet_id

            # Actualiza estado normalizado (best-effort)
            if self._state is not None:
                try:
                    self._state.apply_packet(
                        packet_id=int(hdr.packet_id),
                        payload=data,
                        session_time=float(hdr.session_time),
                        player_index=int(hdr.player_car_index),
                    )
                except Exception:
                    self._stats.decode_errors += 1
                    if self._log.isEnabledFor(logging.DEBUG):
                        self._log.exception("apply_packet failed")

            if self._log.isEnabledFor(logging.DEBUG):
                self._log.debug(
                    "id=%s ver=%s sess=%s t=%.3f frame=%s len=%s",
                    hdr.packet_id,
                    hdr.packet_version,
                    hdr.session_uid,
                    hdr.session_time,
                    hdr.frame_identifier,
                    len(data),
                )