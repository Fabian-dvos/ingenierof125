from __future__ import annotations

import asyncio
import logging

from ingenierof125.core.stats import RuntimeStats

log = logging.getLogger("ingenierof125.udp")


class _Protocol(asyncio.DatagramProtocol):
    def __init__(self, out_queue: "asyncio.Queue[bytes]", drop_when_full: bool, stats: RuntimeStats) -> None:
        self._out = out_queue
        self._drop_when_full = drop_when_full
        self.stats = stats

    def datagram_received(self, data: bytes, addr) -> None:
        # RuntimeStats fields reales:
        #   udp_rx, udp_dropq
        self.stats.udp_rx += 1

        if self._drop_when_full and self._out.full():
            self.stats.udp_dropq += 1
            return

        try:
            self._out.put_nowait(data)
        except asyncio.QueueFull:
            self.stats.udp_dropq += 1

    def error_received(self, exc: Exception) -> None:
        log.error("UDP error_received: %s", exc)


class UdpListener:
    def __init__(
        self,
        host: str,
        port: int,
        out_queue: "asyncio.Queue[bytes]",
        drop_when_full: bool,
        stats: RuntimeStats,
    ) -> None:
        self.host = host
        self.port = port
        self._out = out_queue
        self._drop_when_full = drop_when_full
        self._stats = stats
        self._stop = asyncio.Event()

    async def run(self) -> None:
        loop = asyncio.get_running_loop()
        transport, _ = await loop.create_datagram_endpoint(
            lambda: _Protocol(self._out, self._drop_when_full, self._stats),
            local_addr=(self.host, self.port),
        )
        try:
            await self._stop.wait()
        finally:
            transport.close()

    def stop(self) -> None:
        self._stop.set()