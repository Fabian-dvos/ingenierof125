from __future__ import annotations

import asyncio
import logging
import time
from dataclasses import dataclass, field
from typing import Optional

from ingenierof125.state.manager import StateManager

log = logging.getLogger("ingenierof125.stats")


@dataclass(slots=True)
class RuntimeStats:
    started_ts: float = field(default_factory=time.time)

    udp_rx: int = 0
    udp_dropq: int = 0

    replay_sent: int = 0
    dispatched_in: int = 0

    drop_bad_hdr: int = 0
    drop_fmt: int = 0
    drop_year: int = 0
    drop_ver: int = 0

    rec_written: int = 0
    rec_drop: int = 0

    ids: list[int] = field(default_factory=list)
    dec_err: int = 0
    player_car_index: int = 0

    @property
    def uptime_s(self) -> float:
        return time.time() - self.started_ts

    # -----------------------
    # Compat aliases (viejo -> nuevo)
    # -----------------------
    @property
    def udp_received(self) -> int:
        return self.udp_rx

    @udp_received.setter
    def udp_received(self, v: int) -> None:
        self.udp_rx = int(v)

    @property
    def udp_dropped_queue(self) -> int:
        return self.udp_dropq

    @udp_dropped_queue.setter
    def udp_dropped_queue(self, v: int) -> None:
        self.udp_dropq = int(v)

    @property
    def dropped_bad_header(self) -> int:
        return self.drop_bad_hdr

    @dropped_bad_header.setter
    def dropped_bad_header(self, v: int) -> None:
        self.drop_bad_hdr = int(v)

    @property
    def dropped_format_mismatch(self) -> int:
        return self.drop_fmt

    @dropped_format_mismatch.setter
    def dropped_format_mismatch(self, v: int) -> None:
        self.drop_fmt = int(v)

    @property
    def dropped_game_year_mismatch(self) -> int:
        return self.drop_year

    @dropped_game_year_mismatch.setter
    def dropped_game_year_mismatch(self, v: int) -> None:
        self.drop_year = int(v)

    @property
    def dropped_packet_version_mismatch(self) -> int:
        return self.drop_ver

    @dropped_packet_version_mismatch.setter
    def dropped_packet_version_mismatch(self, v: int) -> None:
        self.drop_ver = int(v)

    @property
    def decode_errors(self) -> int:
        return self.dec_err

    @decode_errors.setter
    def decode_errors(self, v: int) -> None:
        self.dec_err = int(v)


class StatsReporter:
    def __init__(
        self,
        *,
        stats: RuntimeStats,
        state_mgr: StateManager,
        interval_s: float = 1.0,
        queue: Optional[asyncio.Queue[bytes]] = None,
    ) -> None:
        self.stats = stats
        self.state_mgr = state_mgr
        self.interval_s = max(0.1, float(interval_s))
        self.queue = queue
        self._stop = asyncio.Event()

    def stop(self) -> None:
        self._stop.set()

    async def run(self, stop_evt: asyncio.Event) -> None:
        while not stop_evt.is_set() and not self._stop.is_set():
            log.info(self._format())
            try:
                await asyncio.wait_for(stop_evt.wait(), timeout=self.interval_s)
            except asyncio.TimeoutError:
                pass

    def _format(self) -> str:
        qsize = self.queue.qsize() if self.queue is not None else 0
        qmax = self.queue.maxsize if self.queue is not None else 0

        ids = self.stats.ids
        ids_txt = ids[-8:] if ids else []

        # state (sin duplicar stale/t)
        try:
            state_line = self.state_mgr.format_brief() if hasattr(self.state_mgr, "format_brief") else self.state_mgr.format_one_line()
            st = self.state_mgr.stale_flags()
            stale_line = f"stale(session={st.session} lap={st.lap} status={st.status} telem={st.telemetry} dmg={st.damage})"
            t_line = f"t={self.state_mgr.state.latest_session_time:.3f} player={self.state_mgr.state.player_index} decErr={self.state_mgr.state.decode_errors}"
        except Exception:
            state_line = "state=?"
            stale_line = "stale(?)"
            t_line = "t=?"

        return (
            f"up={self.stats.uptime_s:.1f}s "
            f"udp_rx={self.stats.udp_rx} udp_dropQ={self.stats.udp_dropq} "
            f"replay_sent={self.stats.replay_sent} dispatched_in={self.stats.dispatched_in} "
            f"drop_bad_hdr={self.stats.drop_bad_hdr} drop_fmt={self.stats.drop_fmt} drop_year={self.stats.drop_year} drop_ver={self.stats.drop_ver} "
            f"rec_ok={self.stats.rec_written} rec_drop={self.stats.rec_drop} "
            f"q={qsize}/{qmax} ids={ids_txt} "
            f"state={state_line} | {stale_line} | {t_line}"
        )