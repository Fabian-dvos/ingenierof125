from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Tuple


def _as_int(v: Any, default: int) -> int:
    try:
        x = int(v)
        return x if x > 0 else default
    except Exception:
        return default


def _as_float(v: Any, default: float) -> float:
    try:
        return float(v)
    except Exception:
        return default


def _as_bool(v: Any, default: bool) -> bool:
    try:
        return bool(v)
    except Exception:
        return default


def _as_str(v: Any, default: str) -> str:
    try:
        s = str(v)
        return s if s else default
    except Exception:
        return default


def _parse_listen(s: str) -> Tuple[str, int]:
    s = (s or "").strip()
    if not s:
        return ("0.0.0.0", 20777)
    if ":" not in s:
        return (s, 20777)
    host, port_s = s.rsplit(":", 1)
    host = host.strip() or "0.0.0.0"
    try:
        port = int(port_s)
    except Exception:
        port = 20777
    if port <= 0:
        port = 20777
    return (host, port)


@dataclass(slots=True)
class AppConfig:
    # logging
    log_level: str = "INFO"
    log_dir: str = "logs"

    # expected UDP header defaults (F1 25 / 2025)
    packet_format: int = 2025
    game_year: int = 25
    game_major: int = 1
    game_minor: int = 0
    packet_version: int = 1

    # mode
    listen: str = "0.0.0.0:20777"
    replay: str = ""
    replay_speed: float = 1.0
    replay_no_sleep: bool = False

    # queues
    queue_maxsize: int = 2048
    dispatch_maxsize: int = 2048

    # recording
    record: bool = False
    record_dir: str = "recordings"

    # observability
    stats_interval: float = 0.0
    state_interval: float = 0.0

    # engine/rules
    no_engine: bool = False
    rules_path: str = "rules/v1.json"
    comm_throttle: float = 0.0

    # supervisor
    no_supervisor: bool = False

    # --- Aliases compatibles (para evitar futuros “AttributeError”) ---
    @property
    def record_enabled(self) -> bool:
        return bool(self.record)

    @property
    def replay_path(self) -> str:
        return self.replay

    @property
    def stats_interval_s(self) -> float:
        return float(self.stats_interval)

    @property
    def state_interval_s(self) -> float:
        return float(self.state_interval)

    @property
    def udp_host(self) -> str:
        return _parse_listen(self.listen)[0]

    @property
    def udp_port(self) -> int:
        return _parse_listen(self.listen)[1]

    @classmethod
    def from_obj(cls, obj: Any) -> "AppConfig":
        # IMPORTANTE: con dataclass(slots=True) no usar cls.campo como default (member_descriptor)
        base = cls()
        get = getattr

        cfg = cls(
            log_level=_as_str(get(obj, "log_level", base.log_level), base.log_level),
            log_dir=_as_str(get(obj, "log_dir", base.log_dir), base.log_dir),

            packet_format=_as_int(get(obj, "packet_format", base.packet_format), base.packet_format),
            game_year=_as_int(get(obj, "game_year", base.game_year), base.game_year),
            game_major=_as_int(get(obj, "game_major", base.game_major), base.game_major),
            game_minor=_as_int(get(obj, "game_minor", base.game_minor), base.game_minor),
            packet_version=_as_int(get(obj, "packet_version", base.packet_version), base.packet_version),

            listen=_as_str(get(obj, "listen", base.listen), base.listen),
            replay=_as_str(get(obj, "replay", base.replay), base.replay),
            replay_speed=_as_float(get(obj, "replay_speed", base.replay_speed), base.replay_speed),
            replay_no_sleep=_as_bool(get(obj, "replay_no_sleep", base.replay_no_sleep), base.replay_no_sleep),

            queue_maxsize=_as_int(get(obj, "queue_maxsize", base.queue_maxsize), base.queue_maxsize),
            dispatch_maxsize=_as_int(get(obj, "dispatch_maxsize", base.dispatch_maxsize), base.dispatch_maxsize),

            record=_as_bool(get(obj, "record", base.record), base.record),
            record_dir=_as_str(get(obj, "record_dir", base.record_dir), base.record_dir),

            stats_interval=_as_float(get(obj, "stats_interval", base.stats_interval), base.stats_interval),
            state_interval=_as_float(get(obj, "state_interval", base.state_interval), base.state_interval),

            no_engine=_as_bool(get(obj, "no_engine", base.no_engine), base.no_engine),
            rules_path=_as_str(get(obj, "rules_path", base.rules_path), base.rules_path),
            comm_throttle=_as_float(get(obj, "comm_throttle", base.comm_throttle), base.comm_throttle),

            no_supervisor=_as_bool(get(obj, "no_supervisor", base.no_supervisor), base.no_supervisor),
        )

        if cfg.replay_speed <= 0:
            cfg.replay_speed = 1.0
        return cfg