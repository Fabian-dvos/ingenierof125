diff --git a/ingenierof125/__init__.py b/ingenierof125/__init__.py
new file mode 100644
index 0000000..c7c2f10
--- /dev/null
+++ b/ingenierof125/__init__.py
@@ -0,0 +1,7 @@
+"""
+ingenierof125
+
+Base del sistema para un ingeniero virtual (F1 25).
+"""
+
+__version__ = "0.1.0"
diff --git a/ingenierof125/__main__.py b/ingenierof125/__main__.py
new file mode 100644
index 0000000..f4eae5a
--- /dev/null
+++ b/ingenierof125/__main__.py
@@ -0,0 +1,6 @@
+from __future__ import annotations
+
+from ingenierof125.cli import main
+
+if __name__ == "__main__":
+    raise SystemExit(main())
diff --git a/ingenierof125/app.py b/ingenierof125/app.py
new file mode 100644
index 0000000..e7a2b0b
--- /dev/null
+++ b/ingenierof125/app.py
@@ -0,0 +1,94 @@
+from __future__ import annotations
+
+import asyncio
+import logging
+
+from ingenierof125.core.config import AppConfig
+from ingenierof125.core.logging_setup import setup_logging
+from ingenierof125.core.stats import StatsReporter
+from ingenierof125.telemetry.dispatcher import PacketDispatcher
+from ingenierof125.telemetry.handlers.debug import debug_header_logger
+from ingenierof125.telemetry.udp_listener import UdpListener
+
+
+async def run_app(cfg: AppConfig) -> None:
+    """
+    Runtime principal (async):
+    - Listener UDP con cola acotada (backpressure)
+    - Dispatcher que parsea header y enruta por packet_id
+    - Reporter de stats (pps, drops, etc.)
+    """
+    setup_logging(cfg)
+    log = logging.getLogger("ingenierof125")
+    log.info("Starting (udp=%s:%s format=%s year=%s)", cfg.udp_host, cfg.udp_port, cfg.packet_format, cfg.game_year)
+
+    queue: asyncio.Queue[bytes] = asyncio.Queue(maxsize=cfg.queue_maxsize)
+    listener = UdpListener(
+        host=cfg.udp_host,
+        port=cfg.udp_port,
+        out_queue=queue,
+        drop_when_full=True,
+    )
+
+    dispatcher = PacketDispatcher(
+        expected_packet_format=cfg.packet_format,
+        expected_game_year=cfg.game_year,
+    )
+    # Handler por defecto (solo loguea headers en DEBUG)
+    dispatcher.register_default(debug_header_logger)
+
+    stats = StatsReporter(dispatcher.stats, interval_s=cfg.stats_interval_s)
+
+    listener_task = asyncio.create_task(listener.run(), name="udp-listener")
+    dispatch_task = asyncio.create_task(dispatcher.run(queue), name="packet-dispatcher")
+    stats_task = asyncio.create_task(stats.run(), name="stats-reporter")
+
+    try:
+        await asyncio.gather(listener_task, dispatch_task, stats_task)
+    finally:
+        log.info("Shutting down...")
+        dispatcher.stop()
+        listener.stop()
+        stats.stop()
+        for t in (listener_task, dispatch_task, stats_task):
+            t.cancel()
+        await asyncio.gather(listener_task, dispatch_task, stats_task, return_exceptions=True)
diff --git a/ingenierof125/cli.py b/ingenierof125/cli.py
new file mode 100644
index 0000000..5b55e52
--- /dev/null
+++ b/ingenierof125/cli.py
@@ -0,0 +1,82 @@
+from __future__ import annotations
+
+import argparse
+import asyncio
+import logging
+
+from ingenierof125.app import run_app
+from ingenierof125.core.config import AppConfig
+from ingenierof125.core.supervisor import run_with_supervisor
+
+
+def _build_parser() -> argparse.ArgumentParser:
+    p = argparse.ArgumentParser(prog="ingenierof125", add_help=True)
+    p.add_argument("--udp-host", default=None, help="Host para escuchar UDP (default: 0.0.0.0)")
+    p.add_argument("--udp-port", type=int, default=None, help="Puerto UDP (default: 20777)")
+    p.add_argument("--packet-format", type=int, default=None, help="m_packetFormat esperado (default: 2025)")
+    p.add_argument("--game-year", type=int, default=None, help="m_gameYear esperado (default: 25)")
+    p.add_argument("--queue-maxsize", type=int, default=None, help="Tamaño máximo de cola UDP (default: 2048)")
+    p.add_argument("--stats-interval", type=float, default=None, help="Segundos entre logs de stats (default: 2.0)")
+    p.add_argument(
+        "--log-level",
+        default=None,
+        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
+        help="Nivel de log (default: INFO)",
+    )
+    p.add_argument("--no-supervisor", action="store_true", help="Ejecutar sin auto-restart")
+    return p
+
+
+def main(argv: list[str] | None = None) -> int:
+    args = _build_parser().parse_args(argv)
+
+    cfg = AppConfig.from_env().override(
+        udp_host=args.udp_host,
+        udp_port=args.udp_port,
+        packet_format=args.packet_format,
+        game_year=args.game_year,
+        queue_maxsize=args.queue_maxsize,
+        stats_interval_s=args.stats_interval,
+        log_level=args.log_level,
+    )
+
+    if args.no_supervisor:
+        logging.basicConfig(level=getattr(logging, cfg.log_level))
+        asyncio.run(run_app(cfg))
+        return 0
+
+    return run_with_supervisor(cfg, run_app)
diff --git a/ingenierof125/core/__init__.py b/ingenierof125/core/__init__.py
new file mode 100644
index 0000000..d9d2a16
--- /dev/null
+++ b/ingenierof125/core/__init__.py
@@ -0,0 +1 @@
+# Core utilities (config, logging, supervisor, stats)
diff --git a/ingenierof125/core/config.py b/ingenierof125/core/config.py
new file mode 100644
index 0000000..b8f7dd1
--- /dev/null
+++ b/ingenierof125/core/config.py
@@ -0,0 +1,97 @@
+from __future__ import annotations
+
+import os
+from dataclasses import dataclass, replace
+
+
+def _env(name: str, default: str) -> str:
+    v = os.getenv(name)
+    return default if v is None or v.strip() == "" else v.strip()
+
+
+def _env_int(name: str, default: int) -> int:
+    raw = os.getenv(name)
+    if raw is None or raw.strip() == "":
+        return default
+    try:
+        return int(raw.strip())
+    except ValueError:
+        return default
+
+
+def _env_float(name: str, default: float) -> float:
+    raw = os.getenv(name)
+    if raw is None or raw.strip() == "":
+        return default
+    try:
+        return float(raw.strip())
+    except ValueError:
+        return default
+
+
+@dataclass(frozen=True, slots=True)
+class AppConfig:
+    udp_host: str = "0.0.0.0"
+    udp_port: int = 20777
+
+    # F1 25
+    packet_format: int = 2025
+    game_year: int = 25
+
+    log_level: str = "INFO"
+    log_dir: str = "logs"
+    log_file: str = "ingenierof125.log"
+
+    queue_maxsize: int = 2048
+    stats_interval_s: float = 2.0
+
+    supervisor_backoff_min_s: float = 0.5
+    supervisor_backoff_max_s: float = 10.0
+
+    @staticmethod
+    def from_env() -> "AppConfig":
+        return AppConfig(
+            udp_host=_env("ING_UDP_HOST", "0.0.0.0"),
+            udp_port=_env_int("ING_UDP_PORT", 20777),
+            packet_format=_env_int("ING_PACKET_FORMAT", 2025),
+            game_year=_env_int("ING_GAME_YEAR", 25),
+            log_level=_env("ING_LOG_LEVEL", "INFO").upper(),
+            log_dir=_env("ING_LOG_DIR", "logs"),
+            log_file=_env("ING_LOG_FILE", "ingenierof125.log"),
+            queue_maxsize=_env_int("ING_QUEUE_MAXSIZE", 2048),
+            stats_interval_s=_env_float("ING_STATS_INTERVAL_S", 2.0),
+        )
+
+    def override(
+        self,
+        udp_host: str | None = None,
+        udp_port: int | None = None,
+        packet_format: int | None = None,
+        game_year: int | None = None,
+        queue_maxsize: int | None = None,
+        stats_interval_s: float | None = None,
+        log_level: str | None = None,
+    ) -> "AppConfig":
+        return replace(
+            self,
+            udp_host=self.udp_host if udp_host is None else udp_host,
+            udp_port=self.udp_port if udp_port is None else udp_port,
+            packet_format=self.packet_format if packet_format is None else packet_format,
+            game_year=self.game_year if game_year is None else game_year,
+            queue_maxsize=self.queue_maxsize if queue_maxsize is None else queue_maxsize,
+            stats_interval_s=self.stats_interval_s if stats_interval_s is None else stats_interval_s,
+            log_level=self.log_level if log_level is None else log_level,
+        )
diff --git a/ingenierof125/core/logging_setup.py b/ingenierof125/core/logging_setup.py
new file mode 100644
index 0000000..b2d3dc1
--- /dev/null
+++ b/ingenierof125/core/logging_setup.py
@@ -0,0 +1,56 @@
+from __future__ import annotations
+
+import logging
+import os
+from logging.handlers import RotatingFileHandler
+
+from ingenierof125.core.config import AppConfig
+
+
+def setup_logging(cfg: AppConfig) -> None:
+    """
+    Logging estable para procesos largos:
+    - Consola + archivo rotativo (evita crecer infinito)
+    """
+    os.makedirs(cfg.log_dir, exist_ok=True)
+    log_path = os.path.join(cfg.log_dir, cfg.log_file)
+
+    level = getattr(logging, cfg.log_level, logging.INFO)
+    fmt = logging.Formatter(
+        fmt="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
+        datefmt="%Y-%m-%d %H:%M:%S",
+    )
+
+    root = logging.getLogger()
+    root.setLevel(level)
+
+    for h in list(root.handlers):
+        root.removeHandler(h)
+
+    ch = logging.StreamHandler()
+    ch.setLevel(level)
+    ch.setFormatter(fmt)
+
+    fh = RotatingFileHandler(
+        log_path,
+        maxBytes=5 * 1024 * 1024,
+        backupCount=5,
+        encoding="utf-8",
+    )
+    fh.setLevel(level)
+    fh.setFormatter(fmt)
+
+    root.addHandler(ch)
+    root.addHandler(fh)
diff --git a/ingenierof125/core/stats.py b/ingenierof125/core/stats.py
new file mode 100644
index 0000000..c0f7f8a
--- /dev/null
+++ b/ingenierof125/core/stats.py
@@ -0,0 +1,87 @@
+from __future__ import annotations
+
+import asyncio
+import logging
+import time
+from dataclasses import dataclass, field
+
+
+@dataclass(slots=True)
+class PacketStats:
+    received: int = 0
+    dropped_queue: int = 0
+    dropped_bad_header: int = 0
+    dropped_format_mismatch: int = 0
+    by_packet_id: dict[int, int] = field(default_factory=dict)
+
+
+class StatsReporter:
+    def __init__(self, stats: PacketStats, interval_s: float = 2.0) -> None:
+        self._stats = stats
+        self._interval_s = max(0.5, float(interval_s))
+        self._stop = asyncio.Event()
+        self._log = logging.getLogger("ingenierof125.stats")
+
+        self._last_ts = time.monotonic()
+        self._last_received = 0
+
+    def stop(self) -> None:
+        self._stop.set()
+
+    async def run(self) -> None:
+        while not self._stop.is_set():
+            await asyncio.sleep(self._interval_s)
+            now = time.monotonic()
+            dt = max(1e-6, now - self._last_ts)
+            delta = self._stats.received - self._last_received
+            pps = delta / dt
+
+            self._log.info(
+                "rx=%s (%.1f pkt/s) dropQ=%s dropHdr=%s dropFmt=%s ids=%s",
+                self._stats.received,
+                pps,
+                self._stats.dropped_queue,
+                self._stats.dropped_bad_header,
+                self._stats.dropped_format_mismatch,
+                dict(sorted(self._stats.by_packet_id.items())) if self._stats.by_packet_id else {},
+            )
+
+            self._last_ts = now
+            self._last_received = self._stats.received
diff --git a/ingenierof125/core/supervisor.py b/ingenierof125/core/supervisor.py
new file mode 100644
index 0000000..0b2f48f
--- /dev/null
+++ b/ingenierof125/core/supervisor.py
@@ -0,0 +1,74 @@
+from __future__ import annotations
+
+import asyncio
+import logging
+import time
+from collections.abc import Awaitable, Callable
+
+from ingenierof125.core.config import AppConfig
+from ingenierof125.core.logging_setup import setup_logging
+
+
+def run_with_supervisor(cfg: AppConfig, runner: Callable[[AppConfig], Awaitable[None]]) -> int:
+    """
+    Supervisor simple:
+    - Ejecuta el loop principal.
+    - Si hay excepción no controlada, reinicia con backoff.
+    """
+    setup_logging(cfg)
+    log = logging.getLogger("ingenierof125.supervisor")
+
+    backoff = cfg.supervisor_backoff_min_s
+    while True:
+        try:
+            log.info("Launching app (supervised)")
+            asyncio.run(runner(cfg))
+            log.info("App exited normally")
+            return 0
+        except KeyboardInterrupt:
+            log.info("Interrupted by user")
+            return 0
+        except Exception:
+            log.exception("App crashed (will restart)")
+            time.sleep(backoff)
+            backoff = min(backoff * 2, cfg.supervisor_backoff_max_s)
diff --git a/ingenierof125/telemetry/__init__.py b/ingenierof125/telemetry/__init__.py
new file mode 100644
index 0000000..e8b9db7
--- /dev/null
+++ b/ingenierof125/telemetry/__init__.py
@@ -0,0 +1 @@
+# Telemetry ingestion + protocol parsing (F1 25)
diff --git a/ingenierof125/telemetry/dispatcher.py b/ingenierof125/telemetry/dispatcher.py
new file mode 100644
index 0000000..2f1c5aa
--- /dev/null
+++ b/ingenierof125/telemetry/dispatcher.py
@@ -0,0 +1,93 @@
+from __future__ import annotations
+
+import asyncio
+import logging
+from collections.abc import Awaitable, Callable
+
+from ingenierof125.core.stats import PacketStats
+from ingenierof125.telemetry.protocol import PacketHeader
+
+Handler = Callable[[PacketHeader, bytes], Awaitable[None]]
+
+
+class PacketDispatcher:
+    def __init__(self, expected_packet_format: int, expected_game_year: int) -> None:
+        self._log = logging.getLogger("ingenierof125.dispatcher")
+        self._stop = asyncio.Event()
+        self._handlers: dict[int, Handler] = {}
+        self._default_handler: Handler | None = None
+
+        self._expected_packet_format = expected_packet_format
+        self._expected_game_year = expected_game_year
+
+        self.stats = PacketStats()
+
+    def stop(self) -> None:
+        self._stop.set()
+
+    def register(self, packet_id: int, handler: Handler) -> None:
+        self._handlers[packet_id] = handler
+
+    def register_default(self, handler: Handler) -> None:
+        self._default_handler = handler
+
+    async def run(self, in_queue: "asyncio.Queue[bytes]") -> None:
+        self._log.info("Dispatcher running")
+        while not self._stop.is_set():
+            try:
+                data = await asyncio.wait_for(in_queue.get(), timeout=0.5)
+            except asyncio.TimeoutError:
+                continue
+
+            self.stats.received += 1
+
+            hdr = PacketHeader.try_parse(data)
+            if hdr is None:
+                self.stats.dropped_bad_header += 1
+                continue
+
+            # Filtro defensivo para evitar interpretar basura de otro formato
+            if hdr.packet_format != self._expected_packet_format or hdr.game_year != self._expected_game_year:
+                self.stats.dropped_format_mismatch += 1
+                continue
+
+            self.stats.by_packet_id[hdr.packet_id] = self.stats.by_packet_id.get(hdr.packet_id, 0) + 1
+
+            handler = self._handlers.get(hdr.packet_id) or self._default_handler
+            if handler is None:
+                continue
+
+            try:
+                await handler(hdr, data)
+            except Exception:
+                self._log.exception("Handler failed for packet_id=%s", hdr.packet_id)
diff --git a/ingenierof125/telemetry/handlers/__init__.py b/ingenierof125/telemetry/handlers/__init__.py
new file mode 100644
index 0000000..a0a3f9e
--- /dev/null
+++ b/ingenierof125/telemetry/handlers/__init__.py
@@ -0,0 +1 @@
+# Packet handlers live here
diff --git a/ingenierof125/telemetry/handlers/debug.py b/ingenierof125/telemetry/handlers/debug.py
new file mode 100644
index 0000000..c7b5a0b
--- /dev/null
+++ b/ingenierof125/telemetry/handlers/debug.py
@@ -0,0 +1,16 @@
+from __future__ import annotations
+
+import logging
+
+from ingenierof125.telemetry.protocol import PacketHeader
+
+
+async def debug_header_logger(hdr: PacketHeader, data: bytes) -> None:
+    """
+    Handler por defecto: loguea el header solo en DEBUG para no spamear.
+    """
+    log = logging.getLogger("ingenierof125.debug")
+    if log.isEnabledFor(logging.DEBUG):
+        log.debug("id=%s ver=%s sess=%s t=%.3f frame=%s len=%s", hdr.packet_id, hdr.packet_version, hdr.session_uid, hdr.session_time, hdr.frame_identifier, len(data))
diff --git a/ingenierof125/telemetry/protocol.py b/ingenierof125/telemetry/protocol.py
new file mode 100644
index 0000000..6f1c2fb
--- /dev/null
+++ b/ingenierof125/telemetry/protocol.py
@@ -0,0 +1,85 @@
+from __future__ import annotations
+
+import struct
+from dataclasses import dataclass
+from enum import IntEnum
+
+
+class PacketId(IntEnum):
+    MOTION = 0
+    SESSION = 1
+    LAP_DATA = 2
+    EVENT = 3
+    PARTICIPANTS = 4
+    CAR_SETUPS = 5
+    CAR_TELEMETRY = 6
+    CAR_STATUS = 7
+    FINAL_CLASSIFICATION = 8
+    LOBBY_INFO = 9
+    CAR_DAMAGE = 10
+    SESSION_HISTORY = 11
+    TYRE_SETS = 12
+    MOTION_EX = 13
+    TIME_TRIAL = 14
+    LAP_POSITIONS = 15
+
+
+@dataclass(frozen=True, slots=True)
+class PacketHeader:
+    """
+    Header F1 25 (29 bytes) según especificación oficial.
+    Little-endian, packed.
+    """
+
+    packet_format: int
+    game_year: int
+    game_major_version: int
+    game_minor_version: int
+    packet_version: int
+    packet_id: int
+    session_uid: int
+    session_time: float
+    frame_identifier: int
+    overall_frame_identifier: int
+    player_car_index: int
+    secondary_player_car_index: int
+
+    _STRUCT = struct.Struct("<HBBBBBQfIIBB")  # 29 bytes
+
+    @staticmethod
+    def try_parse(data: bytes) -> "PacketHeader | None":
+        if len(data) < PacketHeader._STRUCT.size:
+            return None
+        try:
+            (
+                pf,
+                gy,
+                gmaj,
+                gmin,
+                pver,
+                pid,
+                suid,
+                st,
+                frame,
+                oframe,
+                pci,
+                spci,
+            ) = PacketHeader._STRUCT.unpack_from(data, 0)
+            return PacketHeader(
+                packet_format=pf,
+                game_year=gy,
+                game_major_version=gmaj,
+                game_minor_version=gmin,
+                packet_version=pver,
+                packet_id=pid,
+                session_uid=suid,
+                session_time=st,
+                frame_identifier=frame,
+                overall_frame_identifier=oframe,
+                player_car_index=pci,
+                secondary_player_car_index=spci,
+            )
+        except Exception:
+            return None
diff --git a/ingenierof125/telemetry/udp_listener.py b/ingenierof125/telemetry/udp_listener.py
new file mode 100644
index 0000000..9a2b8d1
--- /dev/null
+++ b/ingenierof125/telemetry/udp_listener.py
@@ -0,0 +1,104 @@
+from __future__ import annotations
+
+import asyncio
+import logging
+from dataclasses import dataclass
+
+
+@dataclass(slots=True)
+class _UdpProtocol(asyncio.DatagramProtocol):
+    out_queue: "asyncio.Queue[bytes]"
+    drop_when_full: bool
+    log: logging.Logger
+    received: int = 0
+    dropped: int = 0
+
+    def datagram_received(self, data: bytes, addr) -> None:  # type: ignore[override]
+        self.received += 1
+        if self.drop_when_full and self.out_queue.full():
+            self.dropped += 1
+            return
+        try:
+            self.out_queue.put_nowait(data)
+        except asyncio.QueueFull:
+            self.dropped += 1
+
+
+class UdpListener:
+    def __init__(
+        self,
+        host: str,
+        port: int,
+        out_queue: "asyncio.Queue[bytes]",
+        drop_when_full: bool = True,
+    ) -> None:
+        self._host = host
+        self._port = port
+        self._out_queue = out_queue
+        self._drop_when_full = drop_when_full
+
+        self._log = logging.getLogger("ingenierof125.udp")
+        self._stop = asyncio.Event()
+        self._transport: asyncio.DatagramTransport | None = None
+        self._protocol: _UdpProtocol | None = None
+
+    def stop(self) -> None:
+        self._stop.set()
+        if self._transport is not None:
+            self._transport.close()
+
+    async def run(self) -> None:
+        loop = asyncio.get_running_loop()
+        self._protocol = _UdpProtocol(
+            out_queue=self._out_queue,
+            drop_when_full=self._drop_when_full,
+            log=self._log,
+        )
+        transport, _ = await loop.create_datagram_endpoint(
+            lambda: self._protocol, local_addr=(self._host, self._port)
+        )
+        self._transport = transport  # type: ignore[assignment]
+        self._log.info("Listening UDP on %s:%s", self._host, self._port)
+
+        try:
+            while not self._stop.is_set():
+                await asyncio.sleep(1.0)
+                if self._protocol and self._protocol.dropped > 0:
+                    self._log.warning(
+                        "UDP drops: received=%s dropped=%s (queue_max=%s)",
+                        self._protocol.received,
+                        self._protocol.dropped,
+                        self._out_queue.maxsize,
+                    )
+        finally:
+            self.stop()
diff --git a/scripts/run_dev.ps1 b/scripts/run_dev.ps1
new file mode 100644
index 0000000..4d1c7c9
--- /dev/null
+++ b/scripts/run_dev.ps1
@@ -0,0 +1,24 @@
+$ErrorActionPreference = "Stop"
+
+if (-not (Test-Path ".venv")) {
+  python -m venv .venv
+}
+
+.\.venv\Scripts\python.exe -m pip install --upgrade pip | Out-Null
+
+Write-Host "Running (Ctrl+C para salir)..." -ForegroundColor Green
+.\.venv\Scripts\python.exe -m ingenierof125 --no-supervisor
diff --git a/tests/test_packet_header.py b/tests/test_packet_header.py
new file mode 100644
index 0000000..0c1c2a4
--- /dev/null
+++ b/tests/test_packet_header.py
@@ -0,0 +1,37 @@
+from __future__ import annotations
+
+import unittest
+
+from ingenierof125.telemetry.protocol import PacketHeader
+
+
+class TestPacketHeader(unittest.TestCase):
+    def test_rejects_too_short(self) -> None:
+        self.assertIsNone(PacketHeader.try_parse(b"\x00\x01"))
+
+    def test_parses_header_size(self) -> None:
+        # Construye un header mínimo válido con valores simples.
+        # Solo verificamos que parsea, no que el paquete sea real.
+        header_size = PacketHeader._STRUCT.size  # 29 bytes
+        raw = bytearray(header_size)
+        # packet_format=2025 (0x07E9 little endian)
+        raw[0] = 0xE9
+        raw[1] = 0x07
+        raw[2] = 25  # game year
+        raw[3] = 1   # major
+        raw[4] = 0   # minor
+        raw[5] = 1   # packet version
+        raw[6] = 6   # packet id
+        hdr = PacketHeader.try_parse(bytes(raw))
+        self.assertIsNotNone(hdr)
+        assert hdr is not None
+        self.assertEqual(hdr.packet_format, 2025)
+        self.assertEqual(hdr.game_year, 25)
+        self.assertEqual(hdr.packet_id, 6)
+
+
+if __name__ == "__main__":
+    unittest.main()
diff --git a/docs/GAME_SETTINGS.md b/docs/GAME_SETTINGS.md
new file mode 100644
index 0000000..b0b2b5a
--- /dev/null
+++ b/docs/GAME_SETTINGS.md
@@ -0,0 +1,20 @@
+# F1 25 - Ajustes recomendados (UDP)
+
+En el juego:
+
+- UDP Telemetry: **On**
+- UDP IP Address: **127.0.0.1** (si corrés todo en la misma PC)
+- UDP Port: **20777** (default)
+- UDP Format: **2025**
+
+Notas:
+- Los valores llegan en **Little Endian** y **packed** (sin padding).
+- Cada paquete empieza con un header de **29 bytes**.
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
new file mode 100644
index 0000000..e9e8d3a
--- /dev/null
+++ b/docs/ARCHITECTURE.md
@@ -0,0 +1,26 @@
+# Arquitectura (base)
+
+Objetivo: proceso estable 8h+, sin crecimiento de memoria y con degradación controlada.
+
+## Componentes
+
+- `UdpListener`: recibe datagramas y los mete en una cola acotada.
+- `PacketDispatcher`: parsea `PacketHeader` y enruta por `packet_id`.
+- `StatsReporter`: reporta ritmo de llegada y drops.
+- `Supervisor`: reinicia ante crash con backoff.
+
+## Filosofía
+
+- Cola acotada + drop para evitar OOM si el consumidor se atrasa.
+- Parsing defensivo del header (tamaño + try/except).
+- Logs rotativos para no llenar disco.

